<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather Pattern ML Analyzer</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üå¶Ô∏è</text></svg>">
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            animation: fadeInDown 0.8s ease;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.95;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.15);
            backdrop-filter: blur(10px);
            animation: fadeInUp 0.8s ease;
        }

        #map {
            height: 500px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .station-info {
            min-height: 500px;
            display: flex;
            flex-direction: column;
        }

        .station-header {
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .station-header h2 {
            font-size: 1.5rem;
            margin-bottom: 5px;
        }

        .station-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
            font-size: 0.9rem;
        }

        .chart-container {
            margin-bottom: 20px;
        }

        .chart-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        #tempChart, #correlationChart, #anomalyChart {
            max-height: 350px;
        }

        .insights-panel {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .insight-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }

        .insight-icon {
            font-size: 24px;
            margin-right: 10px;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top: 3px solid #667eea;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        .error-message {
            background: #ff6b6b;
            color: white;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            display: none;
        }

        .error-message.active {
            display: block;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 20px 0;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.9;
            margin-top: 5px;
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .marker-cluster {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .custom-marker {
            background: #667eea;
            color: white;
            padding: 2px 6px;
            border-radius: 12px;
            font-weight: 600;
            font-size: 10px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.3);
            min-width: 20px;
            text-align: center;
        }

        .station-selector {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
            min-width: 250px;
        }

        .station-selector h3 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 14px;
            font-weight: 600;
        }

        .station-selector select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 12px;
            background: white;
        }

        .station-selector select:focus {
            outline: none;
            border-color: #667eea;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üå¶Ô∏è Weather Pattern ML Analyzer</h1>
            <p>Interactive ASOS station analysis with ML-powered insights</p>
        </div>

        <div class="main-content">
            <div class="panel">
                <div class="station-selector">
                    <h3>üìç Select Station</h3>
                    <select id="stationDropdown">
                        <option value="">Choose a station...</option>
                    </select>
                </div>
                <div id="map"></div>
                <div class="error-message" id="mapError"></div>
            </div>

            <div class="panel station-info">
                <div id="stationPlaceholder" style="text-align: center; padding: 50px; color: #666;">
                    <h3>Select a station to analyze</h3>
                    <p style="margin-top: 10px;">Use the dropdown above or zoom in on the map to see station markers</p>
                    <p style="margin-top: 5px; font-size: 0.9em; opacity: 0.8;">Markers appear when zoomed in closely for better map visibility</p>
                </div>
                
                <div id="stationContent" style="display: none;">
                    <div class="station-header">
                        <h2 id="stationName">Station Name</h2>
                        <div class="station-details">
                            <div><strong>ID:</strong> <span id="stationId"></span></div>
                            <div><strong>State:</strong> <span id="stationState"></span></div>
                            <div><strong>Lat:</strong> <span id="stationLat"></span></div>
                            <div><strong>Lon:</strong> <span id="stationLon"></span></div>
                        </div>
                    </div>

                    <div class="loading" id="dataLoading">
                        <div class="spinner"></div>
                        <p style="margin-top: 10px;">Loading weather data...</p>
                    </div>

                    <div class="error-message" id="dataError"></div>
                    
                    <div id="sampleDataNotice" style="display: none; background: #4CAF50; color: white; padding: 10px; border-radius: 8px; margin: 10px 0;">
                        üìä <strong>Demo Mode:</strong> Showing sample weather data for demonstration purposes.
                    </div>
                    
                    <div id="realDataNotice" style="display: none; background: #2196F3; color: white; padding: 10px; border-radius: 8px; margin: 10px 0;">
                        üå¶Ô∏è <strong>Live Data:</strong> Showing real weather data from Windborne Systems API.
                    </div>

                    <div id="weatherContent" style="display: none;">
                        <div class="stats-grid">
                            <div class="stat-card">
                                <div class="stat-value" id="avgTemp">--</div>
                                <div class="stat-label">Avg Temp (¬∞F)</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="avgHumidity">--</div>
                                <div class="stat-label">Avg Humidity (%)</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="dataPoints">--</div>
                                <div class="stat-label">Data Points</div>
                            </div>
                        </div>

                        <div class="chart-container">
                            <div class="chart-title">üìà Temperature Trends & Predictions</div>
                            <canvas id="tempChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="analysisPanel" class="panel" style="display: none;">
            <div class="chart-container">
                <div class="chart-title">üî¨ Weather Parameter Correlations</div>
                <canvas id="correlationChart"></canvas>
            </div>

            <div class="insights-panel">
                <h3 style="margin-bottom: 15px;">ü§ñ ML Insights</h3>
                <div id="insightsList"></div>
            </div>

            <div class="chart-container" style="margin-top: 20px;">
                <div class="chart-title">‚ö†Ô∏è Anomaly Detection</div>
                <canvas id="anomalyChart"></canvas>
            </div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- TensorFlow.js for ML -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>

    <script>
        // Global variables
        let map;
        let stations = [];
        let currentStation = null;
        let weatherData = null;
        let charts = {};
        let rateLimitQueue = [];
        let lastRequestTime = 0;
        let stationMarkers = [];
        const RATE_LIMIT_DELAY = 3000; // 3 seconds between requests (20/min limit)
        const MIN_ZOOM_FOR_MARKERS = 6; // Only show markers when zoomed in

        // Initialize map
        function initMap() {
            map = L.map('map').setView([39.8283, -98.5795], 4); // Center on USA

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);

            // Add zoom event listener for marker visibility
            map.on('zoomend', updateMarkerVisibility);

            loadStations();
        }

        // Rate limiting function
        async function rateLimitedFetch(url) {
            const now = Date.now();
            const timeSinceLastRequest = now - lastRequestTime;
            
            if (timeSinceLastRequest < RATE_LIMIT_DELAY) {
                await new Promise(resolve => setTimeout(resolve, RATE_LIMIT_DELAY - timeSinceLastRequest));
            }
            
            lastRequestTime = Date.now();
            
            try {
                console.log('Fetching:', url);
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    },
                    mode: 'cors'
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('API response received:', data.length || 'unknown length');
                return data;
            } catch (error) {
                console.error('Fetch error:', error);
                throw error;
            }
        }

        // Load stations
        async function loadStations() {
            try {
                console.log('Loading stations...');
                const data = await rateLimitedFetch('https://sfc.windbornesystems.com/stations');
                stations = data;
                console.log('Stations loaded:', stations.length);
                
                // Clear existing markers
                stationMarkers.forEach(marker => map.removeLayer(marker));
                stationMarkers = [];
                
                // Populate dropdown
                populateStationDropdown();
                
                // Add markers to map (but don't show them yet)
                let markerCount = 0;
                stations.forEach(station => {
                    if (station.latitude && station.longitude) {
                        const marker = L.marker([station.latitude, station.longitude], {
                            icon: L.divIcon({
                                className: 'custom-marker',
                                html: `<div class="custom-marker">${station.station_id.substring(0, 3)}</div>`,
                                iconSize: [30, 15],
                                iconAnchor: [15, 7]
                            })
                        });
                        
                        marker.stationData = station;
                        marker.on('click', () => selectStation(station));
                        
                        marker.bindPopup(`
                            <strong>${station.station_name || station.station_id}</strong><br>
                            ${station.station_network || 'Unknown Network'}<br>
                            <small>Click to analyze</small>
                        `);
                        
                        stationMarkers.push(marker);
                        markerCount++;
                    }
                });
                
                console.log('Markers created:', markerCount);
                
                // Update marker visibility based on current zoom
                updateMarkerVisibility();
                
                if (markerCount === 0) {
                    document.getElementById('mapError').textContent = 'No valid station data found.';
                    document.getElementById('mapError').classList.add('active');
                }
            } catch (error) {
                console.error('Error loading stations:', error);
                document.getElementById('mapError').textContent = 'Failed to load stations. Please refresh.';
                document.getElementById('mapError').classList.add('active');
            }
        }

        // Populate station dropdown
        function populateStationDropdown() {
            const dropdown = document.getElementById('stationDropdown');
            dropdown.innerHTML = '<option value="">Choose a station...</option>';
            
            // Group stations by state/network
            const groupedStations = {};
            stations.forEach(station => {
                const group = station.station_network || 'Unknown';
                if (!groupedStations[group]) {
                    groupedStations[group] = [];
                }
                groupedStations[group].push(station);
            });
            
            // Add options grouped by state/network
            Object.keys(groupedStations).sort().forEach(group => {
                const optgroup = document.createElement('optgroup');
                optgroup.label = group;
                
                groupedStations[group].forEach(station => {
                    const option = document.createElement('option');
                    option.value = station.station_id;
                    option.textContent = `${station.station_id} - ${station.station_name || 'Unknown Name'}`;
                    optgroup.appendChild(option);
                });
                
                dropdown.appendChild(optgroup);
            });
            
            // Add dropdown change event listener
            dropdown.addEventListener('change', function() {
                if (this.value) {
                    const selectedStation = stations.find(s => s.station_id === this.value);
                    if (selectedStation) {
                        selectStation(selectedStation);
                        // Pan to the station
                        map.setView([selectedStation.latitude, selectedStation.longitude], Math.max(map.getZoom(), 8));
                    }
                }
            });
        }

        // Update marker visibility based on zoom level
        function updateMarkerVisibility() {
            const currentZoom = map.getZoom();
            const shouldShowMarkers = currentZoom >= MIN_ZOOM_FOR_MARKERS;
            
            stationMarkers.forEach(marker => {
                if (shouldShowMarkers) {
                    if (!map.hasLayer(marker)) {
                        marker.addTo(map);
                    }
                } else {
                    if (map.hasLayer(marker)) {
                        map.removeLayer(marker);
                    }
                }
            });
        }

        // Select station
        async function selectStation(station) {
            try {
                currentStation = station;
                
                // Update UI
                document.getElementById('stationPlaceholder').style.display = 'none';
                document.getElementById('stationContent').style.display = 'block';
                document.getElementById('weatherContent').style.display = 'none';
                document.getElementById('analysisPanel').style.display = 'none';
                
                // Display station info
                document.getElementById('stationName').textContent = station.station_name || station.station_id;
                document.getElementById('stationId').textContent = station.station_id;
                document.getElementById('stationState').textContent = station.station_network || 'N/A';
                document.getElementById('stationLat').textContent = station.latitude?.toFixed(4) || 'N/A';
                document.getElementById('stationLon').textContent = station.longitude?.toFixed(4) || 'N/A';
                
                // Load weather data
                await loadWeatherData(station.station_id);
            } catch (error) {
                console.error('Error selecting station:', error);
                // Still show the station info even if weather data fails
                document.getElementById('weatherContent').style.display = 'block';
                document.getElementById('analysisPanel').style.display = 'block';
            }
        }

        // Load weather data
        async function loadWeatherData(stationId) {
            document.getElementById('dataLoading').classList.add('active');
            document.getElementById('dataError').classList.remove('active');
            
            try {
                console.log('Loading weather data for station:', stationId);
                
                // Try the historical weather endpoint first
                let data;
                try {
                    data = await rateLimitedFetch(`https://sfc.windbornesystems.com/historical_weather?station=${stationId}`);
                } catch (apiError) {
                    console.log('Historical weather API failed, generating sample data:', apiError);
                    // Generate sample data if API fails
                    data = generateSampleWeatherData(stationId);
                    document.getElementById('sampleDataNotice').style.display = 'block';
                }
                
                // Handle corrupted data
                weatherData = cleanWeatherData(data);
                
                if (weatherData && weatherData.length > 0) {
                    document.getElementById('dataLoading').classList.remove('active');
                    document.getElementById('sampleDataNotice').style.display = 'none';
                    document.getElementById('realDataNotice').style.display = 'block';
                    document.getElementById('weatherContent').style.display = 'block';
                    document.getElementById('analysisPanel').style.display = 'block';
                    
                    analyzeWeatherData();
                } else {
                    throw new Error('No valid data available');
                }
            } catch (error) {
                console.error('Error loading weather data:', error);
                document.getElementById('dataLoading').classList.remove('active');
                document.getElementById('dataError').textContent = 'Failed to load weather data. Using sample data instead.';
                document.getElementById('dataError').classList.add('active');
                
                // Generate sample data as fallback
                weatherData = generateSampleWeatherData(stationId);
                document.getElementById('realDataNotice').style.display = 'none';
                document.getElementById('sampleDataNotice').style.display = 'block';
                document.getElementById('weatherContent').style.display = 'block';
                document.getElementById('analysisPanel').style.display = 'block';
                analyzeWeatherData();
            }
        }

        // Generate sample weather data for demonstration
        function generateSampleWeatherData(stationId) {
            const data = [];
            const now = new Date();
            
            // Generate 30 days of sample data
            for (let i = 30; i >= 0; i--) {
                const date = new Date(now.getTime() - (i * 24 * 60 * 60 * 1000));
                
                // Generate realistic weather data with some randomness
                const baseTemp = 70 + Math.sin(i * 0.2) * 15; // Seasonal variation
                const tempVariation = (Math.random() - 0.5) * 20; // Daily variation
                const temperature = baseTemp + tempVariation;
                
                const humidity = Math.max(20, Math.min(95, 60 + Math.sin(i * 0.3) * 20 + (Math.random() - 0.5) * 30));
                const pressure = 29.5 + (Math.random() - 0.5) * 1.0;
                const windSpeed = Math.max(0, Math.random() * 25);
                const precipitation = Math.random() > 0.8 ? Math.random() * 2 : 0;
                
                data.push({
                    timestamp: date.toISOString(),
                    temperature: Math.round(temperature * 10) / 10,
                    humidity: Math.round(humidity),
                    pressure: Math.round(pressure * 100) / 100,
                    wind_speed: Math.round(windSpeed * 10) / 10,
                    precipitation: Math.round(precipitation * 100) / 100
                });
            }
            
            console.log('Generated sample data for station:', stationId, 'with', data.length, 'records');
            return data;
        }

        // Clean corrupted weather data
        function cleanWeatherData(data) {
            // Handle API response format: {points: [...], points_count: 134, station: "BUR", ...}
            let weatherPoints = [];
            
            if (data && typeof data === 'object') {
                if (data.points && Array.isArray(data.points)) {
                    // API format: {points: [...], ...}
                    weatherPoints = data.points;
                    console.log('Using API data format with', weatherPoints.length, 'points');
                } else if (Array.isArray(data)) {
                    // Direct array format
                    weatherPoints = data;
                    console.log('Using direct array format with', weatherPoints.length, 'points');
                }
            }
            
            if (!Array.isArray(weatherPoints)) {
                console.log('No valid weather points found');
                return [];
            }
            
            return weatherPoints.filter(entry => {
                // Validate essential fields
                return entry && 
                       typeof entry.temperature !== 'undefined' &&
                       !isNaN(entry.temperature) &&
                       entry.temperature > -100 && 
                       entry.temperature < 150 &&
                       entry.timestamp;
            }).map(entry => ({
                timestamp: entry.timestamp,
                temperature: parseFloat(entry.temperature),
                humidity: parseFloat(entry.dewpoint) || null, // API uses 'dewpoint' instead of 'humidity'
                pressure: parseFloat(entry.pressure) || null,
                windSpeed: calculateWindSpeed(entry.wind_x, entry.wind_y), // Calculate from wind components
                precipitation: parseFloat(entry.precip) || 0 // API uses 'precip' instead of 'precipitation'
            }));
        }
        
        // Calculate wind speed from wind components
        function calculateWindSpeed(windX, windY) {
            if (windX === null || windY === null || isNaN(windX) || isNaN(windY)) {
                return null;
            }
            return Math.sqrt(windX * windX + windY * windY);
        }

        // Analyze weather data with ML
        async function analyzeWeatherData() {
            if (!weatherData || weatherData.length === 0) return;
            
            // Calculate basic statistics
            const temps = weatherData.map(d => d.temperature).filter(t => !isNaN(t));
            const avgTemp = temps.reduce((a, b) => a + b, 0) / temps.length;
            
            const humidities = weatherData.map(d => d.humidity).filter(h => h !== null && !isNaN(h));
            const avgHumidity = humidities.length > 0 ? 
                humidities.reduce((a, b) => a + b, 0) / humidities.length : 0;
            
            document.getElementById('avgTemp').textContent = avgTemp.toFixed(1);
            document.getElementById('avgHumidity').textContent = avgHumidity.toFixed(0);
            document.getElementById('dataPoints').textContent = weatherData.length;
            
            // Create visualizations
            createTemperatureChart();
            createCorrelationChart();
            detectAnomalies();
            generateMLInsights();
        }

        // Create temperature chart with trend prediction
        function createTemperatureChart() {
            const ctx = document.getElementById('tempChart').getContext('2d');
            
            // Prepare data
            const sortedData = weatherData.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            const labels = sortedData.map(d => new Date(d.timestamp).toLocaleDateString());
            const temperatures = sortedData.map(d => d.temperature);
            
            // Simple linear regression for trend
            const trend = calculateTrend(temperatures);
            
            // Destroy existing chart if it exists
            if (charts.tempChart) charts.tempChart.destroy();
            
            charts.tempChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels.slice(-30), // Last 30 points
                    datasets: [{
                        label: 'Temperature (¬∞F)',
                        data: temperatures.slice(-30),
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        tension: 0.4
                    }, {
                        label: 'Trend',
                        data: trend.slice(-30),
                        borderColor: '#f093fb',
                        borderDash: [5, 5],
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true }
                    }
                }
            });
        }

        // Calculate trend line
        function calculateTrend(data) {
            const n = data.length;
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
            
            for (let i = 0; i < n; i++) {
                sumX += i;
                sumY += data[i];
                sumXY += i * data[i];
                sumX2 += i * i;
            }
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            return data.map((_, i) => slope * i + intercept);
        }

        // Create correlation chart
        function createCorrelationChart() {
            const ctx = document.getElementById('correlationChart').getContext('2d');
            
            // Calculate correlations
            const correlations = calculateCorrelations();
            
            if (charts.correlationChart) charts.correlationChart.destroy();
            
            charts.correlationChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: Object.keys(correlations),
                    datasets: [{
                        label: 'Correlation Coefficient',
                        data: Object.values(correlations),
                        backgroundColor: Object.values(correlations).map(v => 
                            v > 0 ? 'rgba(102, 126, 234, 0.8)' : 'rgba(245, 87, 108, 0.8)'
                        )
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            min: -1,
                            max: 1
                        }
                    }
                }
            });
        }

        // Calculate correlations between weather parameters
        function calculateCorrelations() {
            const correlations = {};
            
            // Temperature vs Humidity
            const tempHumidityCorr = calculatePearsonCorrelation(
                weatherData.map(d => d.temperature),
                weatherData.map(d => d.humidity).filter(h => h !== null)
            );
            if (!isNaN(tempHumidityCorr)) correlations['Temp vs Humidity'] = tempHumidityCorr;
            
            // Temperature vs Pressure
            const tempPressureCorr = calculatePearsonCorrelation(
                weatherData.map(d => d.temperature),
                weatherData.map(d => d.pressure).filter(p => p !== null)
            );
            if (!isNaN(tempPressureCorr)) correlations['Temp vs Pressure'] = tempPressureCorr;
            
            // Wind vs Temperature
            const windTempCorr = calculatePearsonCorrelation(
                weatherData.map(d => d.windSpeed).filter(w => w !== null),
                weatherData.map(d => d.temperature)
            );
            if (!isNaN(windTempCorr)) correlations['Wind vs Temp'] = windTempCorr;
            
            return correlations;
        }

        // Pearson correlation coefficient
        function calculatePearsonCorrelation(x, y) {
            const n = Math.min(x.length, y.length);
            if (n < 2) return 0;
            
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0, sumY2 = 0;
            
            for (let i = 0; i < n; i++) {
                if (!isNaN(x[i]) && !isNaN(y[i])) {
                    sumX += x[i];
                    sumY += y[i];
                    sumXY += x[i] * y[i];
                    sumX2 += x[i] * x[i];
                    sumY2 += y[i] * y[i];
                }
            }
            
            const correlation = (n * sumXY - sumX * sumY) / 
                Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
            
            return isNaN(correlation) ? 0 : correlation;
        }

        // Detect anomalies using statistical methods
        function detectAnomalies() {
            const temps = weatherData.map(d => d.temperature);
            const mean = temps.reduce((a, b) => a + b, 0) / temps.length;
            const stdDev = Math.sqrt(temps.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / temps.length);
            
            const anomalies = weatherData.map((d, i) => ({
                index: i,
                value: d.temperature,
                isAnomaly: Math.abs(d.temperature - mean) > 2 * stdDev
            }));
            
            const ctx = document.getElementById('anomalyChart').getContext('2d');
            
            if (charts.anomalyChart) charts.anomalyChart.destroy();
            
            charts.anomalyChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Normal',
                        data: anomalies.filter(a => !a.isAnomaly).map(a => ({x: a.index, y: a.value})),
                        backgroundColor: 'rgba(102, 126, 234, 0.6)'
                    }, {
                        label: 'Anomaly',
                        data: anomalies.filter(a => a.isAnomaly).map(a => ({x: a.index, y: a.value})),
                        backgroundColor: 'rgba(245, 87, 108, 0.8)',
                        pointRadius: 8
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: 'Time Index' } },
                        y: { title: { display: true, text: 'Temperature (¬∞F)' } }
                    }
                }
            });
        }

        // Generate ML insights
        function generateMLInsights() {
            const insights = [];
            
            // Temperature trend insight
            const temps = weatherData.map(d => d.temperature);
            const trend = calculateTrend(temps);
            const trendDirection = trend[trend.length - 1] > trend[0] ? 'increasing' : 'decreasing';
            insights.push({
                icon: 'üìä',
                text: `Temperature trend is ${trendDirection} over the analyzed period`
            });
            
            // Volatility insight
            const stdDev = Math.sqrt(temps.map(x => Math.pow(x - temps.reduce((a,b) => a+b,0)/temps.length, 2)).reduce((a,b) => a+b) / temps.length);
            const volatility = stdDev > 15 ? 'high' : stdDev > 8 ? 'moderate' : 'low';
            insights.push({
                icon: 'üå°Ô∏è',
                text: `Temperature volatility is ${volatility} (œÉ = ${stdDev.toFixed(1)}¬∞F)`
            });
            
            // Correlation insight
            const correlations = calculateCorrelations();
            const strongCorr = Object.entries(correlations).find(([k, v]) => Math.abs(v) > 0.5);
            if (strongCorr) {
                insights.push({
                    icon: 'üîó',
                    text: `Strong correlation found: ${strongCorr[0]} (r = ${strongCorr[1].toFixed(2)})`
                });
            }
            
            // Anomaly insight
            const anomalyCount = weatherData.filter(d => {
                const mean = temps.reduce((a,b) => a+b,0) / temps.length;
                const std = Math.sqrt(temps.map(x => Math.pow(x - mean, 2)).reduce((a,b) => a+b) / temps.length);
                return Math.abs(d.temperature - mean) > 2 * std;
            }).length;
            
            insights.push({
                icon: '‚ö†Ô∏è',
                text: `Detected ${anomalyCount} anomalous readings (${(anomalyCount/weatherData.length*100).toFixed(1)}% of data)`
            });
            
            // Display insights
            const insightsList = document.getElementById('insightsList');
            insightsList.innerHTML = insights.map(insight => `
                <div class="insight-item">
                    <span class="insight-icon">${insight.icon}</span>
                    <span>${insight.text}</span>
                </div>
            `).join('');
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', initMap);
    </script>
</body>
</html>